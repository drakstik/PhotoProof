package main

import (
	"PhotoProof/v2/camera"
	"PhotoProof/v2/field_elements"
	"crypto/rand"
	"fmt"
	"math/big"

	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark-crypto/hash"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/std/algebra/native/twistededwards"
	"github.com/consensys/gnark/std/hash/mimc"
	"github.com/consensys/gnark/std/signature/eddsa"

	ctwistededwards "github.com/consensys/gnark-crypto/ecc/twistededwards"

	ceddsa "github.com/consensys/gnark-crypto/signature/eddsa"
)

// "reflect"

// gnark is a zk-SNARK library written in Go. Circuits are regular structs.
// The inputs must be of type frontend.Variable and make up the witness.
// The witness has a
//   - secret part --> known to the prover only
//   - public part --> known to the prover and the verifier
type Circuit struct {
	PublicKey_out eddsa.PublicKey   `gnark:",public"`
	Signature     eddsa.Signature   `gnark:",public"`
	Message       frontend.Variable `gnark:",public"`
}

// Define declares the circuit logic. The compiler then produces a list of constraints
// which must be satisfied (valid witness) in order to create a valid zk-SNARK
// This circuit verifies an EdDSA signature.
func (circuit *Circuit) Define(api frontend.API) error {
	// set the twisted edwards curve to use
	curve, err := twistededwards.NewEdCurve(api, ctwistededwards.BN254)
	if err != nil {
		return err
	}

	// hash function
	mimc, err := mimc.NewMiMC(api)
	if err != nil {
		return err
	}

	// tip: gnark profiles enable circuit developers to measure the number of constraints
	// generated by a part of the (or the entire) circuit, using pprof.
	// see github.com/consensys/gnark/profile

	// verify the EdDSA signature
	eddsa.Verify(curve, circuit.Signature, circuit.Message, circuit.PublicKey_out, &mimc)

	// tip: api.Println behaves like go fmt.Println but accepts frontend.Variable
	// that are resolved at Proving time
	api.Println("message", circuit.Message)

	return nil
}

func main() {
	img, _, _ := camera.TakePhotograph()

	// JSON encode Image_out
	JSON_encoded_image := img.JSON_Encode_Image()

	Image_big_endian_bytes := field_elements.Bytes_to_big_endian(JSON_encoded_image)

	// Generate a signing key
	secretKey, err := ceddsa.New(1, rand.Reader)
	if err != nil {
		fmt.Println(err.Error())
	}

	publicKey := secretKey.Public() // Generate a public signature verification key

	// Instantiate hash function to be used when signing the image
	hFunc := hash.MIMC_BN254.New()

	// Sign the image
	signature, err := secretKey.Sign(Image_big_endian_bytes, hFunc)
	if err != nil {
		fmt.Println("Error: " + err.Error())
	}

	// Instantiate a Circuit
	var circuit Circuit

	// assign values to the Circuit's fields
	circuit.Message = frontend.Variable(new(big.Int).SetBytes(JSON_encoded_image))
	fmt.Println(frontend.Variable(JSON_encoded_image))
	circuit.PublicKey_out.Assign(ctwistededwards.ID(ecc.BN254), publicKey.Bytes()[:32])
	circuit.Signature.Assign(ctwistededwards.ID(ecc.BN254), signature)

	// Generate the witness using the assigned circuit
	// NOTE: This witness includes both secret and public fields!!!
	// fmt.Println(circuit)
	witness, err := frontend.NewWitness(&circuit, ecc.BN254.ScalarField())
	if err != nil {
		fmt.Println("ERROR 1: " + err.Error())
	}

	fmt.Println("Success", witness)

	// _, proof, _ := camera.TakePhotograph()
	// fmt.Println(proof)

	// imgCopy := img1.Copy_Image()

	// img2 := img1.ContrastIncrement(1) // img2 has all pixels of img1 + 1.
	// img1.Equals(imgCopy)              // Images are equal.
	// img1.Equals(img2)                 // Images matrices not equal!
	// img1.ChangeAuthor("Drakstik")
	// img1.Equals(imgCopy) // Images metadata not equal!
	// img1.TransformCheck(img2, 0, 1)
	// img1.TransformCheck(img2, 1, 1)
	// imgCopy.TransformCheck(img1, 2, "Drakstik")

	/*Testing Identity transformation*/
	// compiles our circuit into a R1CS
	// var circuit ComplianceCircuit
	// ccs, _ := frontend.Compile(ecc.BN254.ScalarField(), r1cs.NewBuilder, &circuit)

	// // groth16 zkSNARK: Setup
	// pk, vk, _ := groth16.Setup(ccs)

	// // Instantiate a compliance circuit
	// assignment := ComplianceCircuit{}

	// result, err := verifier.Verifier(img1, proof)
	// fmt.Println(result, err)
}

// import (
// 	"github.com/consensys/gnark-crypto/ecc"
// 	"github.com/consensys/gnark/backend/groth16"
// 	"github.com/consensys/gnark/frontend"
// 	"github.com/consensys/gnark/frontend/cs/r1cs"
// )

// func main() {

// 	// compiles our circuit into a R1CS
// 	var circuit IdentityMatrix
// 	ccs, _ := frontend.Compile(ecc.BN254.ScalarField(), r1cs.NewBuilder, &circuit)

// 	// groth16 zkSNARK: Setup
// 	pk, vk, _ := groth16.Setup(ccs)

// 	// witness definition

// 	a := [3][3]frontend.Variable{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}

// 	b := [3][3]frontend.Variable{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}

// 	assignment := IdentityMatrix{X: a, Y: b} // X is secret, Y is public.
// 	witness, _ := frontend.NewWitness(&assignment, ecc.BN254.ScalarField())
// 	publicWitness, _ := witness.Public()

// 	// groth16: Prove & Verify
// 	proof, _ := groth16.Prove(ccs, pk, witness) // This proof can be sent alongside verification and public witness Y (i.e. the output).
// 	groth16.Verify(proof, vk, publicWitness)
// }

// // A Matrix consists of two fields X and Y with N rows and columns.
// // X and Y are 2D arrays of frontend-Variable that represent pixels of an image.
// type IdentityMatrix struct {
// 	X [3][3]frontend.Variable `gnark:"X, secret"` // X = [N*N]frontend.Variable
// 	Y [3][3]frontend.Variable `gnark:",public"`
// }

// // REQUIRED FOR LIMITATION SHOWCASE
// func (circuit *IdentityMatrix) Define(api frontend.API) error {
// 	api.AssertIsEqual(len(circuit.Y), len(circuit.X))
// 	for i := 0; i < 3; i++ {
// 		for j := 0; j < 3; j++ {
// 			api.AssertIsEqual(circuit.X[i][j], circuit.Y[i][j])
// 		}
// 	}
// 	return nil
// }
